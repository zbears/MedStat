dim tmp(10)
dim led #define the led state
dim connected #a boolean indicating whether the device is connected to bluetooth
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw )
	# Device is not connected yet
	connected = 0
	# Set advertisement interval to 20-30ms using all channels
	call gap_set_adv_parameters(32,48,7)
	#set to advertising mode for bluetooth
	call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
	#set bondable mode
	call sm_set_bondable_mode(1)
	#configure P0_0 as output and P0_1 as output (first arg is port, second is bitmask for each pin direction 11 -> 3)
	call hardware_io_port_config_direction(0,3)
	#write a low output to P0_0 output pins
	call hardware_io_port_write(0,3,0)
	#Start a timer at 1 second interval, handle 0, repeating
	call hardware_set_soft_timer(32768,0,0)
end

# when the timer expires, make the LED shine to the connected status
event hardware_soft_timer(handle)
	# The port write command first is port, second is bitmask for pins, then bitmask for state
	call hardware_io_port_write(0,1,connected)
end

# handle the case of a bluetooth device disconnecting
event connection_disconnected(handle,result)
	#connection disconnected, continue advertising
	    call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
	    connected = 0
end

   # Listen for GATT write events
event attributes_value(connection, reason, handle, offset, value_len, value)
	if value(0:1) = 1 then
		# Write 1 to port 0, pin 1 (variables are 2 due to a bitmasking)
		call hardware_io_port_write(0,2,2)
	else
		# Turn off the LED on P0_1
		call hardware_io_port_write(0,2,0)
	end if
end

# Create a connection event listener
event connection_status(connection,flags,address,address_type,conn_interval,timeout,latency,bonding)
	connected = 1
end

